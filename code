import pandas as pd
from pulp import * # we need pulp for optimization (pip install pulp if you don't have it)
import numpy as np

# Works Cited 
## A Blending Problem : https://coin-or.github.io/pulp/CaseStudies/a_blending_problem.html 

# Read in the file
diet = pd.read_excel('diet.xls')

# There are some cleaning to do as the last three rows of the data includes minimum and maximum nutrient information. 
# Let's see how it looks first before extracting those rows. 
# Additionally, I will store the minimum and maximum nutrient information beforehand.

display(diet.tail(3))

# Collect min and max values for each nutrient
min_nut = list(diet.iloc[65, 3:len(diet.columns)])
max_nut = list(diet.iloc[66, 3:len(diet.columns)])

# Removing the last three rows with min and max nutrient information
diet = diet[:-3]
display(diet.head())

# Creating a nested list of foods and nutrient and price info
diet_data = diet.values.tolist()

# Making a list of foods 
food = [x[0] for x in diet_data]


# Storing each information separately as dict
price = {x[0]:float(x[1]) for x in diet_data}
serving = {x[0]:x[2] for x in diet_data}
calories = {x[0]:float(x[3]) for x in diet_data}
chol = {x[0]:float(x[4]) for x in diet_data}
fat = {x[0]:float(x[5]) for x in diet_data}
sodium = {x[0]:float(x[6]) for x in diet_data}
carb = {x[0]:float(x[7]) for x in diet_data}
fiber = {x[0]:float(x[8]) for x in diet_data}
protein = {x[0]:float(x[9]) for x in diet_data}
vitA = {x[0]:float(x[10]) for x in diet_data}
vitC = {x[0]:float(x[11]) for x in diet_data}
calc = {x[0]:float(x[12]) for x in diet_data}
iron = {x[0]:float(x[13]) for x in diet_data}

## 15.2.1
""" Formulate an optimization model (a linear program) to find the cheapest diet that satisfies the 
maximum and minimum daily nutrition constraints, and solve it using PuLP.  Turn in your code 
and the solution."""
  
# Create Optimization Problem - we want to minimize cost
prob = LpProblem('DietProblem', LpMinimize)

# Create decision variables
food_vars = LpVariable.dicts("food", food, lowBound=0, cat='Continuous')
food_binary = LpVariable.dicts("food_binary", food, lowBound=0, cat='Binary')


# Create Objective Function
prob += lpSum([price[i] * food_vars[i] for i in food])

# Add Constraints - We want each good nutrient to be within min and max range
for nutrient, min_value, max_value in zip(['calories', 'chol', 'fat', 'sodium', 'carb', 
                                           'fiber', 'protein', 'vitA', 'vitC', 'calc', 'iron'], 
                                          min_nut, max_nut):
    prob += lpSum([food_vars[i] * eval(nutrient)[i] for i in food]) >= min_value, f"Min_{nutrient}_constraint"
    prob += lpSum([food_vars[i] * eval(nutrient)[i] for i in food]) <= max_value, f"Max_{nutrient}_constraint"


# Now let's solve the optimization problem 
soln1 = prob.solve()

sol1_dict = {}
print(LpStatus[prob.status])
for v in prob.variables():
    if v.varValue > 0:
        print( f"{v.name} = {v.varValue:.2f}")
    sol1_dict[v.name] = round(v.varValue, 2)
    
print(f"Cost: ${round(value(prob.objective),2)}")













